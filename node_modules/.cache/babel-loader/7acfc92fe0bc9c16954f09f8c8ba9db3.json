{"ast":null,"code":"/**\n * findTop figures out where the top of the TipDisplay should go\n * @param {element} target\n */\nexport const findTop = target => {\n  const margin = 10;\n  const {\n    pageYOffset\n  } = window;\n  const top = Math.round(target.bottom + pageYOffset + margin);\n  return top;\n};\nexport const findHorzTop = (tip, target, align) => {\n  // margin = (margin of carrot from edge of box) - (height of carrot)\n  const margin = tip.height * 0.15 - 8;\n  const {\n    pageYOffset\n  } = window;\n  let top = align === 'center' ? target.top + target.height / 2 : target.top;\n  top += pageYOffset;\n\n  if (align === 'center') {\n    top -= tip.height / 2;\n  } else if (align === 'bottom') {\n    top -= margin;\n  }\n\n  return top;\n};\n/**\n * findBottom figures out where the bottom of the TipDisplay should go\n * @param {element} target\n */\n\nexport const findBottom = target => {\n  const margin = 10;\n  const {\n    pageYOffset\n  } = window;\n  const {\n    clientHeight\n  } = document.documentElement;\n  return Math.round(clientHeight - (target.top + pageYOffset) + margin);\n};\nexport const findHorzBottom = (tip, target) => {\n  // margin = (margin of carrot from edge of box) - (height of carrot)\n  const margin = tip.height * 0.15 - 8;\n  const {\n    pageYOffset\n  } = window;\n  const {\n    clientHeight\n  } = document.documentElement;\n  return Math.round(clientHeight - (target.bottom + pageYOffset) - margin);\n};\n/**\n * findLeft figures out where the left of the TipDisplay should go\n * @param {element} tip\n * @param {element} target\n * @param {string} align horizontal position 'left', 'center', 'right'\n */\n\nexport const findLeft = (tip, target, align) => {\n  // margin = (margin of carrot from edge of box) + (width of carrot)\n  const margin = tip.width * 0.15 + 8; // find horizontal position\n\n  let left = align === 'center' ? target.left + target.width / 2 : target[align];\n  left += window.pageXOffset;\n\n  if (align === 'center') {\n    left -= tip.width / 2;\n  } else if (align === 'right') {\n    left -= target.width / 2 + margin;\n  } else if (align === 'left') {\n    left -= tip.width;\n    left += target.width / 2 + margin;\n  }\n\n  return left;\n};\nexport const findHorzLeft = (tip, target, align) => {\n  const margin = 10;\n\n  if (align === 'right') {\n    return target.right + margin;\n  }\n\n  return target.left - tip.width - margin;\n};\n/**\n * using the above functions setPosition sets\n * top, bottom, and left of tip box\n * based on the alignment specified by user\n * @param {element} tip\n * @param {element} target\n * @param {object} param2 state values\n */\n\nexport const setPosition = (tip, target, {\n  vert,\n  horz,\n  mobileView\n}, isHorizontal) => {\n  if (mobileView) {\n    return {\n      top: 0,\n      bottom: 'unset',\n      left: '0'\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      top: vert !== 'top' ? findHorzTop(tip, target, vert) : 'unset',\n      bottom: vert === 'top' ? findHorzBottom(tip, target) : 'unset',\n      left: findHorzLeft(tip, target, horz)\n    };\n  }\n\n  return {\n    top: vert === 'top' ? 'unset' : findTop(target),\n    bottom: vert === 'bottom' ? 'unset' : findBottom(target),\n    left: findLeft(tip, target, horz)\n  };\n};\nexport const pagePosition = () => {\n  const headerHeight = 47;\n  const windowHeight = window.innerHeight;\n  const scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n  return {\n    top: scrollTop + headerHeight,\n    bot: scrollTop + windowHeight\n  };\n};\n/**\n * @param {element} tip\n * @param {element} target\n * @param {string} vert 'top', 'bottom', 'center'\n */\n\nexport const toolTipPosition = (tip, target, vert, isHorizontal) => {\n  const toolTipHeight = tip.height;\n  let top = 0;\n  let bot = 0;\n\n  if (isHorizontal) {\n    if (vert !== 'top') {\n      top = findHorzTop(tip, target, vert);\n      bot = toolTipHeight + top;\n    } else {\n      bot = findHorzBottom(tip, target);\n      top = bot - toolTipHeight;\n    }\n  } else {\n    top = findTop(target);\n    bot = top + toolTipHeight;\n  }\n\n  return {\n    top,\n    bot\n  };\n};\nexport const isMobile = () => {\n  const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n  return windowWidth <= 600;\n};","map":{"version":3,"sources":["/Users/bmarshall/react-library/src/components/ToolTip/helpers/findLocations.js"],"names":["findTop","target","margin","pageYOffset","window","top","Math","round","bottom","findHorzTop","tip","align","height","findBottom","clientHeight","document","documentElement","findHorzBottom","findLeft","width","left","pageXOffset","findHorzLeft","right","setPosition","vert","horz","mobileView","isHorizontal","pagePosition","headerHeight","windowHeight","innerHeight","scrollTop","undefined","body","parentNode","bot","toolTipPosition","toolTipHeight","isMobile","windowWidth","innerWidth","clientWidth"],"mappings":"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","sourcesContent":["/**\n * findTop figures out where the top of the TipDisplay should go\n * @param {element} target\n */\nexport const findTop = target => {\n    const margin = 10;\n    const { pageYOffset } = window;\n    const top = Math.round(target.bottom + pageYOffset + margin);\n\n    return top;\n};\nexport const findHorzTop = (tip, target, align) => {\n    // margin = (margin of carrot from edge of box) - (height of carrot)\n    const margin = tip.height * 0.15 - 8;\n    const { pageYOffset } = window;\n\n    let top = align === 'center' ? target.top + target.height / 2 : target.top;\n    top += pageYOffset;\n\n    if (align === 'center') {\n        top -= tip.height / 2;\n    } else if (align === 'bottom') {\n        top -= margin;\n    }\n\n    return top;\n};\n\n/**\n * findBottom figures out where the bottom of the TipDisplay should go\n * @param {element} target\n */\nexport const findBottom = target => {\n    const margin = 10;\n    const { pageYOffset } = window;\n    const { clientHeight } = document.documentElement;\n\n    return Math.round(clientHeight - (target.top + pageYOffset) + margin);\n};\nexport const findHorzBottom = (tip, target) => {\n    // margin = (margin of carrot from edge of box) - (height of carrot)\n    const margin = tip.height * 0.15 - 8;\n    const { pageYOffset } = window;\n    const { clientHeight } = document.documentElement;\n\n    return Math.round(clientHeight - (target.bottom + pageYOffset) - margin);\n};\n\n/**\n * findLeft figures out where the left of the TipDisplay should go\n * @param {element} tip\n * @param {element} target\n * @param {string} align horizontal position 'left', 'center', 'right'\n */\nexport const findLeft = (tip, target, align) => {\n    // margin = (margin of carrot from edge of box) + (width of carrot)\n    const margin = tip.width * 0.15 + 8;\n\n    // find horizontal position\n    let left = align === 'center' ? target.left + target.width / 2 : target[align];\n    left += window.pageXOffset;\n\n    if (align === 'center') {\n        left -= tip.width / 2;\n    } else if (align === 'right') {\n        left -= target.width / 2 + margin;\n    } else if (align === 'left') {\n        left -= tip.width;\n        left += target.width / 2 + margin;\n    }\n\n    return left;\n};\nexport const findHorzLeft = (tip, target, align) => {\n    const margin = 10;\n    if (align === 'right') {\n        return target.right + margin;\n    }\n\n    return target.left - tip.width - margin;\n};\n\n/**\n * using the above functions setPosition sets\n * top, bottom, and left of tip box\n * based on the alignment specified by user\n * @param {element} tip\n * @param {element} target\n * @param {object} param2 state values\n */\nexport const setPosition = (tip, target, { vert, horz, mobileView }, isHorizontal) => {\n    if (mobileView) {\n        return {\n            top: 0,\n            bottom: 'unset',\n            left: '0'\n        };\n    }\n\n    if (isHorizontal) {\n        return {\n            top: vert !== 'top' ? findHorzTop(tip, target, vert) : 'unset',\n            bottom: vert === 'top' ? findHorzBottom(tip, target) : 'unset',\n            left: findHorzLeft(tip, target, horz)\n        };\n    }\n    return {\n        top: vert === 'top' ? 'unset' : findTop(target),\n        bottom: vert === 'bottom' ? 'unset' : findBottom(target),\n        left: findLeft(tip, target, horz)\n    };\n};\n\nexport const pagePosition = () => {\n    const headerHeight = 47;\n    const windowHeight = window.innerHeight;\n    const scrollTop =\n        window.pageYOffset !== undefined\n            ? window.pageYOffset\n            : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n\n    return {\n        top: scrollTop + headerHeight,\n        bot: scrollTop + windowHeight\n    };\n};\n\n/**\n * @param {element} tip\n * @param {element} target\n * @param {string} vert 'top', 'bottom', 'center'\n */\nexport const toolTipPosition = (tip, target, vert, isHorizontal) => {\n    const toolTipHeight = tip.height;\n    let top = 0;\n    let bot = 0;\n\n    if (isHorizontal) {\n        if (vert !== 'top') {\n            top = findHorzTop(tip, target, vert);\n            bot = toolTipHeight + top;\n        } else {\n            bot = findHorzBottom(tip, target);\n            top = bot - toolTipHeight;\n        }\n    } else {\n        top = findTop(target);\n        bot = top + toolTipHeight;\n    }\n\n    return { top, bot };\n};\n\nexport const isMobile = () => {\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\n    return windowWidth <= 600;\n};\n"]},"metadata":{},"sourceType":"module"}